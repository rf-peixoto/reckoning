<!-- templates/execution_detail.html -->
{% extends "base.html" %}

{% block content %}
<div class="d-flex justify-between align-center mb-20">
  <h2 style="color: var(--accent);">
    <i class="fas fa-play-circle"></i> Execution Details
  </h2>
  <div class="d-flex gap-10">
    <a href="{{ url_for('executions_list') }}" class="btn btn-secondary">
      <i class="fas fa-history"></i> History
    </a>
    <a href="{{ url_for('index') }}" class="btn btn-secondary">
      <i class="fas fa-arrow-left"></i> Dashboard
    </a>
  </div>
</div>

<div class="card mb-20">
  <div class="card-header">
    <div class="d-flex justify-between align-center">
      <div>
        <div style="font-size: 18px; font-weight: bold; color: var(--text);">
          {{ execution.workflow_name }}
        </div>
        <div style="color: var(--text-muted); font-size: 13px;">
          {{ execution.workflow_description }}
        </div>
      </div>
      <div class="badge" id="execStatusBadge" style="background: var(--secondary); border: 1px solid var(--border);">
        <span id="execStatusText">{{ execution.status }}</span>
      </div>
    </div>
  </div>
  <div class="card-body">
    <div class="d-flex gap-20 flex-wrap" style="font-size: 13px; color: var(--text-muted);">
      <div><strong style="color: var(--text);">Execution ID:</strong> <span id="execId">{{ execution.execution_id }}</span></div>
      <div><strong style="color: var(--text);">Domain:</strong> <span id="execDomain">{{ execution.domain }}</span></div>
      <div><strong style="color: var(--text);">Created:</strong> <span id="execCreated">{{ execution.created_at }}</span></div>
      <div><strong style="color: var(--text);">Started:</strong> <span id="execStarted">{{ execution.started_at or "—" }}</span></div>
      <div><strong style="color: var(--text);">Completed:</strong> <span id="execCompleted">{{ execution.completed_at or "—" }}</span></div>
      <div><strong style="color: var(--text);">Version:</strong> <span id="execVersion">{{ execution.version }}</span></div>
    </div>
  </div>
</div>

<div class="card mb-20">
  <div class="card-header d-flex justify-between align-center">
    <div style="font-weight: bold; color: var(--text);">
      <i class="fas fa-tools"></i> Tools
    </div>
    <div style="color: var(--text-muted); font-size: 12px;">
      Outputs are fetched on-demand to reduce payload size.
    </div>
  </div>

  <div class="card-body" id="toolsContainer">
    {% if tool_order and tool_order|length > 0 %}
      {% for tool in tool_order %}
        <div class="tool-card mb-10" style="background: var(--primary); border: 1px solid var(--border); border-radius: 8px; padding: 12px;">
          <div class="d-flex justify-between align-center">
            <div>
              <div style="display:flex; align-items:center; gap:10px;">
                <div style="width: 10px; height: 10px; border-radius: 50%; background: {{ tool.color or 'var(--accent)' }};"></div>
                <div style="font-weight: bold; color: var(--text);">{{ tool.name }}</div>
                {% if not tool.enabled %}
                  <span class="badge" style="background: var(--secondary); border: 1px solid var(--border); color: var(--text-muted);">disabled</span>
                {% endif %}
              </div>
              <div style="color: var(--text-muted); font-size: 12px; margin-top: 2px;">{{ tool.description }}</div>
            </div>

            <div class="d-flex gap-10 align-center">
              <span class="badge" id="toolStatus_{{ tool.id }}" style="background: var(--secondary); border: 1px solid var(--border); color: var(--text-muted);">
                pending
              </span>
              <button class="btn btn-secondary" style="padding: 6px 10px;" onclick="toggleToolOutput('{{ tool.id }}')" id="btn_{{ tool.id }}" disabled>
                <i class="fas fa-eye"></i> View
              </button>
            </div>
          </div>

          <div id="outputWrap_{{ tool.id }}" style="display:none; margin-top: 10px;">
            <div class="d-flex justify-between align-center mb-10">
              <div style="color: var(--text-muted); font-size: 12px;">
                <span id="meta_{{ tool.id }}"></span>
              </div>
              <button class="btn btn-secondary" style="padding: 6px 10px;" onclick="refreshToolOutput('{{ tool.id }}')">
                <i class="fas fa-rotate"></i> Refresh output
              </button>
            </div>

            <div class="d-flex gap-10 flex-wrap">
              <div style="flex:1; min-width: 280px;">
                <div style="color: var(--text-muted); font-size: 12px; margin-bottom: 6px;"><strong style="color: var(--text);">STDOUT</strong></div>
                <pre class="code-block" id="stdout_{{ tool.id }}" style="max-height: 380px; overflow:auto;"></pre>
              </div>
              <div style="flex:1; min-width: 280px;">
                <div style="color: var(--text-muted); font-size: 12px; margin-bottom: 6px;"><strong style="color: var(--text);">STDERR</strong></div>
                <pre class="code-block" id="stderr_{{ tool.id }}" style="max-height: 380px; overflow:auto;"></pre>
              </div>
            </div>
          </div>
        </div>
      {% endfor %}
    {% else %}
      <div style="color: var(--text-muted);">No tools found for this workflow.</div>
    {% endif %}
  </div>
</div>

<div class="card mb-20">
  <div class="card-header d-flex justify-between align-center">
    <div style="font-weight: bold; color: var(--text);">
      <i class="fas fa-stream"></i> Event Trail
    </div>
    <button class="btn btn-secondary" style="padding: 6px 10px;" onclick="refreshEvents()">
      <i class="fas fa-rotate"></i> Refresh
    </button>
  </div>
  <div class="card-body">
    <div id="eventsBox" class="code-block" style="max-height: 280px; overflow:auto; font-size: 12px;"></div>
  </div>
</div>

<div class="card">
  <div class="card-header d-flex justify-between align-center">
    <div style="font-weight: bold; color: var(--text);">
      <i class="fas fa-code"></i> Raw JSON (debug)
    </div>
    <button class="btn btn-secondary" style="padding: 6px 10px;" onclick="toggleJson()">
      <i class="fas fa-chevron-down"></i> Toggle
    </button>
  </div>
  <div class="card-body" id="jsonWrap" style="display:none;">
    <pre class="code-block" id="rawJson" style="max-height: 320px; overflow:auto;"></pre>
  </div>
</div>

<script>
  const executionId = "{{ execution.execution_id }}";

  // Client-side cache to avoid re-fetching large outputs unnecessarily
  const toolCache = {}; // tool_id -> { output_sha256, error_sha256, loaded: bool }

  let pollDelayMs = 1000;
  const pollDelayMaxMs = 8000;
  let lastVersion = Number("{{ execution.version or 0 }}") || 0;
  let pollTimer = null;

  function setStatusBadge(status) {
    const badge = document.getElementById("execStatusBadge");
    const text = document.getElementById("execStatusText");
    text.textContent = status;

    let color = "var(--text-muted)";
    if (status === "running") color = "var(--warning)";
    if (status === "completed") color = "var(--success)";
    if (status === "failed") color = "var(--danger)";

    badge.style.color = color;
    badge.style.borderColor = "var(--border)";
  }

  function setToolStatus(toolId, status) {
    const el = document.getElementById(`toolStatus_${toolId}`);
    if (!el) return;

    el.textContent = status;

    let color = "var(--text-muted)";
    if (status === "running") color = "var(--warning)";
    if (status === "completed") color = "var(--success)";
    if (status === "failed") color = "var(--danger)";
    if (status === "skipped") color = "var(--text-muted)";

    el.style.color = color;

    // Enable view button only when tool has finished (or failed)
    const btn = document.getElementById(`btn_${toolId}`);
    if (btn) {
      btn.disabled = !(status === "completed" || status === "failed");
    }
  }

  function renderEvents(events) {
    const box = document.getElementById("eventsBox");
    if (!events || events.length === 0) {
      box.textContent = "No events yet.";
      return;
    }
    // Use textContent to avoid injecting HTML from log messages
    const lines = events.map(e => {
      const tool = e.tool_id ? ` tool=${e.tool_id}` : "";
      return `${e.ts} [${e.level}] ${e.type}${tool} - ${e.message}`;
    });
    box.textContent = lines.join("\n");
  }

  function renderRawJson(obj) {
    const el = document.getElementById("rawJson");
    el.textContent = JSON.stringify(obj, null, 2);
  }

  async function refreshEvents() {
    try {
      const resp = await fetch(`/api/execution/${executionId}/events`);
      if (!resp.ok) return;
      const data = await resp.json();
      renderEvents(data.events || []);
    } catch (e) {
      // silent in UI; console for debugging
      console.error("Events fetch failed:", e);
    }
  }

  async function refreshToolOutput(toolId) {
    try {
      const resp = await fetch(`/api/execution/${executionId}/results/${toolId}`);
      if (!resp.ok) return;
      const data = await resp.json();

      // Update cache hashes
      toolCache[toolId] = toolCache[toolId] || {};
      toolCache[toolId].output_sha256 = data.output_sha256 || "";
      toolCache[toolId].error_sha256 = data.error_sha256 || "";
      toolCache[toolId].loaded = true;

      // Use textContent (not innerHTML) to avoid XSS from tool output
      document.getElementById(`stdout_${toolId}`).textContent = data.output || "";
      document.getElementById(`stderr_${toolId}`).textContent = data.error || "";

      const meta = [];
      if (data.start_time) meta.push(`start=${data.start_time}`);
      if (data.end_time) meta.push(`end=${data.end_time}`);
      if (typeof data.exit_code !== "undefined" && data.exit_code !== null) meta.push(`exit=${data.exit_code}`);
      meta.push(`stdout_len=${data.output_len || 0}`);
      meta.push(`stderr_len=${data.error_len || 0}`);
      document.getElementById(`meta_${toolId}`).textContent = meta.join(" | ");

    } catch (e) {
      console.error("Tool output fetch failed:", e);
    }
  }

  function toggleToolOutput(toolId) {
    const wrap = document.getElementById(`outputWrap_${toolId}`);
    if (!wrap) return;

    const willShow = (wrap.style.display === "none");
    wrap.style.display = willShow ? "block" : "none";

    if (willShow) {
      // If not loaded yet, fetch now
      if (!toolCache[toolId] || !toolCache[toolId].loaded) {
        refreshToolOutput(toolId);
      }
    }
  }

  function toggleJson() {
    const wrap = document.getElementById("jsonWrap");
    wrap.style.display = (wrap.style.display === "none") ? "block" : "none";
  }

  async function pollStatus() {
    try {
      const resp = await fetch(`/api/execution/${executionId}/status`);
      if (!resp.ok) {
        scheduleNextPoll(true);
        return;
      }

      const data = await resp.json();
      renderRawJson(data);

      const version = Number(data.version || 0);
      document.getElementById("execVersion").textContent = String(version);
      document.getElementById("execStarted").textContent = data.started_at || "—";
      document.getElementById("execCompleted").textContent = data.completed_at || "—";
      setStatusBadge(data.status || "unknown");

      // Update tool statuses from summaries
      const summaries = data.results_summary || {};
      for (const [toolId, summary] of Object.entries(summaries)) {
        setToolStatus(toolId, summary.status || "pending");

        // If output view is open, refresh only if hashes changed
        const wrap = document.getElementById(`outputWrap_${toolId}`);
        const isOpen = wrap && wrap.style.display !== "none";
        if (isOpen) {
          toolCache[toolId] = toolCache[toolId] || {};
          const outHash = summary.output_sha256 || "";
          const errHash = summary.error_sha256 || "";
          if (toolCache[toolId].output_sha256 !== outHash || toolCache[toolId].error_sha256 !== errHash) {
            refreshToolOutput(toolId);
          }
        }
      }

      // Update event tail quickly
      if (data.events_tail) {
        renderEvents(data.events_tail);
      }

      // Backoff control: reset delay on changes; backoff if no changes
      const changed = (version !== lastVersion);
      lastVersion = version;

      const isTerminal = (data.status === "completed" || data.status === "failed");

      if (changed) {
        pollDelayMs = 1000;
      } else if (!isTerminal) {
        pollDelayMs = Math.min(pollDelayMs * 2, pollDelayMaxMs);
      }

      scheduleNextPoll(isTerminal);

    } catch (e) {
      console.error("Status polling failed:", e);
      scheduleNextPoll(true);
    }
  }

  function scheduleNextPoll(isTerminalOrError) {
    if (pollTimer) clearTimeout(pollTimer);

    if (isTerminalOrError) {
      // One last events refresh for completeness
      refreshEvents();
      return;
    }

    pollTimer = setTimeout(pollStatus, pollDelayMs);
  }

  // Initial render
  setStatusBadge("{{ execution.status }}");
  renderEvents({{ (execution.events or [])[-20:] | tojson }});
  pollStatus();
</script>
{% endblock %}